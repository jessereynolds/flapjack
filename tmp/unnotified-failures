#!/usr/bin/env ruby

# query Redis for checks that we have detected have failed, but haven't yet sent a notification.

require 'optparse'
require 'ostruct'
require 'terminal-table'

require 'oj'
Oj.default_options = { :indent => 0, :mode => :strict }

require 'redis'

# add lib to the default include path
unless $:.include?(File.dirname(__FILE__) + '/../lib/')
  $: << File.dirname(__FILE__) + '/../lib'
end

require 'flapjack/configuration'
require 'flapjack/data/entity_check'

options = OpenStruct.new
options.config = Flapjack::Configuration::DEFAULT_CONFIG_PATH

exe = File.basename(__FILE__)

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{exe} COMMAND [OPTIONS]"

  opts.separator  ""
  opts.separator  "Commands:"
  opts.separator  "     detect"
  opts.separator  ""
  opts.separator  "Options"

  opts.on("-c", "--config [PATH]", String, "PATH to the config file to use") do |c|
    options.config = c
  end

end
optparse.parse!(ARGV)

bail_with_usage = proc do |message|
  puts message
  puts "\n#{optparse}"
  exit(false)
end

if options.help
  puts optparse
  exit
elsif options.version
  puts Flapjack::VERSION
  exit
elsif !["detect"].include?(ARGV[0])
  message = if ARGV.nil? || ARGV.empty?
              "No command provided"
            else
              "Unknown command provided: '#{ARGV[0]}'"
            end
  bail_with_usage.call message
end

FLAPJACK_ENV = ENV['FLAPJACK_ENV'] || 'production'

config = Flapjack::Configuration.new
config.load(options.config)
config_env = config.all
redis_options = config.for_redis

if config_env.nil? || config_env.empty?
  puts "No config data for environment '#{FLAPJACK_ENV}' found in '#{options.config}'"
  exit(false)
end

@redis = Redis.new(redis_options)

case ARGV[0]
when "detect"
  failings = Flapjack::Data::EntityCheck.find_all_failing(:redis => @redis)
  total_failing_checks = failings.length
  unnotified = failings.inject([]) do |memo, failing|
    check = Flapjack::Data::EntityCheck.for_event_id(failing, :redis => @redis)
    max_notified = check.max_notified_severity_of_current_failure
    unless max_notified || check.in_scheduled_maintenance? || check.in_unscheduled_maintenance?
      memo << check
    end
    memo
  end

  if unnotified.empty?
    puts "Great! There's no unnotified failures to be found."
    puts "Total failing checks: #{total_failing_checks}"
  else
    puts "#{unnotified.length} unnotified failures found:"
    headings = ["Entity", "Check", "State", "Last Update", "Enablement"]
    rows = []
    unnotified.each {|check|
      enablement = check.enabled? ? 'Enabled' : 'Disabled'
      rows << [check.entity.name, check.check, check.state, Time.at(check.last_update).to_s, enablement]
    }
    table = Terminal::Table.new :headings => headings, :rows => rows
    puts table
    puts "Total failing checks: #{total_failing_checks}"
  end

else
  bail_with_usage.call "You need to give me something to do, eg. a command like 'import-entities', 'import-clients', etc."
end


